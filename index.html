<!doctype html>
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html; charset=UTF-8" />
    <title>Washington - Example Driven Development for Node.js</title>
    <meta name="description" content="Straightforward testing tool that goes back to the roots" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="shortcut icon" href="favicon.png" />
    <link rel="stylesheet" href="style.css" />
    <link href='http://fonts.googleapis.com/css?family=Inconsolata:400,700' rel='stylesheet' type='text/css'>
  </head>

  <body>
    <main class="grid">
      <h1>Washington ✍</h1>
      <p>Example Driven Development for Node.js</p>

      <proposition>
        <pre><span class="muted">var</span> example <span class="muted">=</span> require<span class="muted">(</span><span class="string">"washington"</span><span class="muted">);</span>
<span class="muted">var</span> assert <span class="muted">=</span> require<span class="muted">(</span><span class="string">"arrest"</span><span class="muted">);</span>

<span class="muted">var</span> add <span class="muted">= function (</span>number<span class="muted">,</span> addition<span class="muted">) {</span>
  <span class="muted">return</span> number <span class="muted">+</span> addition<span class="muted">;</span>
<span class="muted">}</span>

example<span class="muted">(</span><span class="string">"add: 2, 2 will be 4 @wip"</span><span class="muted">, function () {</span>
  assert<span class="muted">.</span>equal<span class="muted">(</span>add<span class="muted">(</span>2<span class="muted">,</span> 2<span class="muted">), </span>4<span class="muted">);</span>
<span class="muted">});</span>

<span class="muted">---</span>
<span class="muted">&gt;</span> washington script.js
<span class="success">✌︎ add: 2 + 2 will be 4 @wip</span> <span class="muted">(1ms)</span>
<span class="success">1 successful</span> <span class="muted">(1ms)</span>
</pre>
      </proposition>

      <clearfix />

      <h2>Install</h2>
      <p>&gt; npm install -g washington</p>

      <h2>Usage</h2>

      <p></p>

      <h2>What is Example Driven Development?</h2>

      <p>It's the practice of writing real life usage examples as tests instead of contrived artificial artifacts.</p>
      <p>It's the practice of writing code that sets an example of how code should be written.</p>
      <p>It's going back to the roots of what testing is. The testing (BDD/TDD) endeavor is a long, complex topic where a lot of opinions coexist and frequently collide. The enlightenment in testing is all about the balance of:</p>

      <ul>
        <li><strong>Coverage</strong>: Good coverage means robust code, but there is such thing as too many tests. Example driven development means that you shouldn't write tests for scenarios that you cannot imagine happening in real life.</li>
        <li><strong>Ergonomics</strong>: The test suite must be easy to run, easy to filter, easy to create. Example driven development means that the tests should lie as close to the tested code as possible, ideally just below it. Example driven development also means that you can ditch complex suite structures to reflect large APIs, favoring instead filterability and really small components. This is better explained by the related principle <a href="dont develop">Don't develop: standardize</a></li>
        <li><strong>Interoperability</strong>: It should be possible to run the test suite in a various of ways: with full fletched command line, human readable output; with various output formats (html, json, xml, ...); optimized for continuous integration, with log-like, one line per test output format; and programatically, so tools can be built on top of the test suite to leverage the test suite results in making progress metrics, API complexity analysis, statistical analysis and all kind of insights that you shouldn't need to parse the command line output or monkeypatch the test runner to be able to extract. Example driven development means treating the examples as first class citizens of the code base, since in the contemporary ecosystem tests are becoming more and more production code. Washington solves that by provinding a powerful interface for interacting with the test suite and the possibility of overriding formatters, and of course full access to the test suite objects with no esoteric structures.</li>
      </ul>
      <p>The bottom line is that you should treat your test examples as production code. Treat the test suite as a citizen of your codebase (do not dwell into "first class", citizens should be equal). In the end it is about the <a href="http://www.catb.org/esr/writings/taoup/html/ch01s06.html">Unix philosophy</a>, the cornerstone of Open Source.</p>

      <h3>What a failing status amounts to</h3>
      <p>The usual practice in mainstream TDD/BDD is to give a lot of attention to assertion/expectation tools. From the extreme linguistic approach of the venerable RSpec in Ruby and Chai in Node, to the spartan assertion tool that is just a macro for firing exceptions on condition of inequality, the implicit premise is that testing it's about confirming the type and value of function returns. It is not. Testing is actually closer to be about having your code running without firing exceptions. The first test is the very fact that you can invoke your API without getting a <code>ReferenceError</code>.</p>
      <p>Asserting behavior is a shorthand for testing conditions of usage of the API, but it is not the essence of what testing is. Although RSpec provided complex expectation semantics, the authors of RSpec and proposers of BDD actually suggest renaming "tests" as "examples", the reason being that as usage examples is as you should consider them. Tests should be consumable as a form of documentation, and is the ideals of BDD where to be realized (something I'm strongly trying to achieve with EDD) tests would be all the documentation you need.</p>
      <p>Imagine a world where the home pages of programming libraries offer live usage examples as documentation which are actual tests, part of the test suite. Several everyday nuisances are immediatly solved: documentation and codebase cannot possible go out of sync (if they do, the test suite will pass to a failing state), and libraries with good coverage are by default completely documented with extensive, trustworthy examples.</p>

      <h3>How Washington fits: small components</h3>
      <p>Getting a step closer to this ideal is what Washington and Example Driven Development are all about. Washington provides a simple enough way of manipulating the examples, without making any kind of assumption about the assertion process (if there is one at all). Washington provides a minimalistic API for example creation that aims to make the inlining of examples in development (or even production!) code an everyday practice, and also it is the case that, by default, examples created with Washington will affect nothing until manually invoked, making them a fit to coexist with production code.</p>
      <p>Washington's <code>example</code> API aims to be a language extension more than a framework. The idea is that examples are shipped as part of the codebase, not just in a separate test suite but maybe also in the runtime: only that if no requirement of them appears, they are automatically garbage collected and make no dent in performance besides the short amount of time that the parsing takes. The upside, having a full example set always at hand, may very well override the drawbacks</p>
      <p>The main challenge is of course avoid bloating the example suite while at the same time making a reasonable coverage of the codebase. In this regard my instinct tells me that we are asking the wrong question: the problem arises entirely as an artifact of the fact that we are building huge applications with lots of internal APIs that, truth be told, could very well be abstracted, shared and built on their own as independent, generic controllers. I had this feeling each time a implemented a User object with the same properties, wondering why haven't we as a community come up with a way of abstracting that. I can only say that I imagine this as being a residue of pre-Open Source culture (you can see how models of your application domain can be perceived as more of a competitive advantage that your build-step, at least from a miopic business management perspective) and our collective perception of we not having enough time to abstract our solutions to the desired level: but I also dare to say that we are not doing enough.</p>
      <p>We can do better. This is my contribution to that hope.</p>

      <h2>License</h2>
      <p>&copy; 2014 Xavier Via<br />
        <a href="https://github.com/xaviervia/washington/blob/master/LICENSE">BSD 2 Clause license.</a></p>

    </main>
  </body>
</html>
